#!/usr/bin/python3

import click
import feedparser
import os
import re
import subprocess

class Episode:
    ''' Describes episode information based on given feed item. '''
    def __init__(self, series: str, title: str, resolution: str, link: str):
        # Yeah, regexp, sorry.
        parsed = re.findall('^s(\d+)e(\d+)(\s-\s)?(.+)', title)
        self.series = series
        self.season = parsed[0][0] or '0'
        self.episode = parsed[0][1] or '0'
        self.title = parsed[0][3] or ''
        self.resolution = resolution
        self.link = link
        self.extension = 'mp4'
        self.weight = f'{self.season}_{self.episode}'

    def get_title(self, series: bool, title: bool, resolution: bool, extension: bool)-> str:
        ''' Returns formatted target filename. '''
        parts = [
            self.series if series else None,
            f'S{self.season}E{self.episode}',
            self.title if title else None,
        ]
        title = ' - '.join([x for x in parts if x is not None])
        if resolution and self.resolution:
            title += f' [{self.resolution}]'
        if extension and self.extension:
            title += f'.{self.extension}'
        return title

    def download(self, dir: str, series: bool, title: bool, resolution: bool):
        ''' Downloads current episode. '''
        if not os.path.exists(dir):
            print(f'Creating "{dir}" directory...')
            os.makedirs(dir)
        filename=self.get_title(series, title, resolution, extension=True)
        path=f'{dir}/{filename}'
        #subprocess.run(f'wget -q --show-progress --continue -O "{path}" "{self.link}"', shell=True)
        subprocess.run(f'curl -# -L -o "{path}" -C - "{self.link}"', shell=True)


@click.command(help='Downloads all series of certain show from kino.pub by PODCAST_URL.')
@click.argument('podcast_url')
@click.option('--seasons', help='Limit downloads to certain seasons (separated by comma). "-1" means all seasons.', prompt='‚úî Enter seasons (separated by comma)', required=True, type=str, default='-1')
@click.option('--dir', help='Output directory. Feed title by default.', default=None)
@click.option('--append-show-name', default=True, help='Appends the show name (feed title) to episode filename.')
@click.option('--append-title', default=False, help='Appends human-readable title to episode filename if exists.')
@click.option('--append-resolution', default=True, help='Appends video resolution to episode filemane.')
def download(podcast_url: str, seasons: str, dir: str, append_show_name: bool, append_title: bool, append_resolution: bool):
    seasons_list = [int(x.strip()) for x in seasons.split(',')]
    feed = feedparser.parse(podcast_url)
    dir = feed.channel.title if dir is None else dir # Use feed title as output dir by default.
    parsed_data: list(Episode) = []
    for item in feed.entries:
        parsed_data.append(Episode(
            series=feed['channel']['title'],
            title=item['title'],
            resolution=item['summary'],
            link=next(x for x in item['links'] if x['type'] == 'video/mp4')['href']
        ))

    # Sort parsed episodes by weight (season+episode).
    parsed_data.sort(key=lambda x:x.weight)

    # If seasons are selected, then filter items.
    if '-1' not in seasons_list:
        # Leave only episodes for needed seasons.
        parsed_data[:] = list(filter(lambda x: int(f'{x.season}') in seasons_list, parsed_data))
        # Raise error if no episodes left to download.
        if not parsed_data:
            raise click.UsageError(f'No episodes found for {seasons} season.')

    if click.confirm(f'ü§ù Confirm downloading [{len(parsed_data)}] episodes', default=True):
        for index, item in enumerate(parsed_data):
            total_episodes=len(parsed_data)
            percentage=str(int((index/total_episodes)*100)).rjust(2, ' ')
            print(f'[ {percentage}% | {index + 1} of {total_episodes} | S{item.season}E{item.episode} ]')
            item.download(dir=dir, series=append_show_name, title=append_title, resolution=append_resolution)

if __name__ == '__main__':
    download()
